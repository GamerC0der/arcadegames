<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetro - p5.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
            flex-direction: column;
        }
        #game-container {
            position: relative;
            width: 512px;
            height: 512px;
            box-shadow: 0 0 20px rgba(255, 119, 168, 0.3);
        }
        canvas {
            display: block;
            image-rendering: pixelated;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        .score {
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #FF77A8;
            text-shadow: 2px 2px #000;
        }
        #status-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            text-align: center;
            width: 100%;
            pointer-events: none;
            line-height: 2;
            text-shadow: 2px 2px #000;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui">
            <div id="score-text" class="score">LINES: 0</div>
        </div>
        <div id="status-text">
            PRESS SPACE TO START<br>
            ARROWS TO MOVE<br>
            UP TO ROTATE<br>
            ESC TO EXIT
        </div>
    </div>

    <script>
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20;
        const MARGIN_X = (400 - (COLS * BLOCK_SIZE)) / 2;
        const MARGIN_Y = (400 - (ROWS * BLOCK_SIZE)) / 2;

        let grid = [];
        let currentPiece;
        let score = 0;
        let gameActive = false;
        let dropInterval = 600;
        let lastDrop = 0;

        const SHAPES = [
            [[1, 1, 1, 1]], // I
            [[1, 1, 1], [0, 1, 0]], // T
            [[1, 1, 1], [1, 0, 0]], // L
            [[1, 1, 1], [0, 0, 1]], // J
            [[1, 1], [1, 1]], // O
            [[1, 1, 0], [0, 1, 1]], // S
            [[0, 1, 1], [1, 1, 0]]  // Z
        ];

        const COLORS = [
            '#29ADFF', '#FF004D', '#00E436', '#FFA300', 
            '#FFEC27', '#83769C', '#FF77A8'
        ];

        function setup() {
            let canvas = createCanvas(400, 400);
            canvas.parent('game-container');
            // Scale the 400x400 canvas to fit 512x512 with pixelation
            canvas.elt.style.width = '512px';
            canvas.elt.style.height = '512px';
            
            initGrid();
            noSmooth();
        }

        function draw() {
            background(5, 5, 5);
            
            // Draw grid border
            stroke(40);
            noFill();
            rect(MARGIN_X - 2, MARGIN_Y - 2, COLS * BLOCK_SIZE + 4, ROWS * BLOCK_SIZE + 4);

            if (gameActive) {
                if (millis() - lastDrop > dropInterval) {
                    moveDown();
                    lastDrop = millis();
                }

                drawGrid();
                drawPiece(currentPiece);
            }
        }

        function initGrid() {
            for (let y = 0; y < ROWS; y++) {
                grid[y] = Array(COLS).fill(0);
            }
        }

        function startGame() {
            initGrid();
            score = 0;
            updateScore();
            gameActive = true;
            document.getElementById('status-text').style.display = 'none';
            spawnPiece();
        }

        function spawnPiece() {
            let id = floor(random(SHAPES.length));
            currentPiece = {
                shape: SHAPES[id],
                color: COLORS[id],
                x: floor(COLS / 2) - floor(SHAPES[id][0].length / 2),
                y: 0
            };

            if (checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
            }
        }

        function drawGrid() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x]) {
                        drawBlock(x, y, grid[y][x]);
                    }
                }
            }
        }

        function drawPiece(p) {
            if (!p) return;
            for (let y = 0; y < p.shape.length; y++) {
                for (let x = 0; x < p.shape[y].length; x++) {
                    if (p.shape[y][x]) {
                        drawBlock(p.x + x, p.y + y, p.color);
                    }
                }
            }
        }

        function drawBlock(x, y, color) {
            fill(color);
            stroke(0);
            strokeWeight(1);
            rect(MARGIN_X + x * BLOCK_SIZE, MARGIN_Y + y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            // Highlight
            noStroke();
            fill(255, 100);
            rect(MARGIN_X + x * BLOCK_SIZE + 2, MARGIN_Y + y * BLOCK_SIZE + 2, BLOCK_SIZE - 10, 3);
        }

        function checkCollision(x, y, shape) {
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        let nx = x + col;
                        let ny = y + row;
                        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
                        if (ny >= 0 && grid[ny][nx]) return true;
                    }
                }
            }
            return false;
        }

        function lockPiece() {
            for (let row = 0; row < currentPiece.shape.length; row++) {
                for (let col = 0; col < currentPiece.shape[row].length; col++) {
                    if (currentPiece.shape[row][col]) {
                        let ny = currentPiece.y + row;
                        let nx = currentPiece.x + col;
                        if (ny >= 0) grid[ny][nx] = currentPiece.color;
                    }
                }
            }
            clearLines();
            spawnPiece();
        }

        function clearLines() {
            let lines = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                if (grid[y].every(cell => cell !== 0)) {
                    grid.splice(y, 1);
                    grid.unshift(Array(COLS).fill(0));
                    lines++;
                    y++;
                }
            }
            if (lines > 0) {
                score += lines;
                updateScore();
            }
        }

        function moveDown() {
            if (!checkCollision(currentPiece.x, currentPiece.y + 1, currentPiece.shape)) {
                currentPiece.y++;
            } else {
                lockPiece();
            }
        }

        function rotatePiece() {
            let newShape = [];
            for (let x = 0; x < currentPiece.shape[0].length; x++) {
                newShape[x] = [];
                for (let y = currentPiece.shape.length - 1; y >= 0; y--) {
                    newShape[x].push(currentPiece.shape[y][x]);
                }
            }
            if (!checkCollision(currentPiece.x, currentPiece.y, newShape)) {
                currentPiece.shape = newShape;
            }
        }

        function keyPressed() {
            if (keyCode === 32) { // SPACE
                if (!gameActive) startGame();
            }
            
            if (!gameActive) return;

            if (keyCode === LEFT_ARROW) {
                if (!checkCollision(currentPiece.x - 1, currentPiece.y, currentPiece.shape)) {
                    currentPiece.x--;
                }
            } else if (keyCode === RIGHT_ARROW) {
                if (!checkCollision(currentPiece.x + 1, currentPiece.y, currentPiece.shape)) {
                    currentPiece.x++;
                }
            } else if (keyCode === DOWN_ARROW) {
                moveDown();
            } else if (keyCode === UP_ARROW) {
                rotatePiece();
            } else if (keyCode === ESCAPE) {
                window.location.href = 'menu.html';
            }
        }

        function updateScore() {
            document.getElementById('score-text').innerText = 'LINES: ' + score;
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('status-text').style.display = 'block';
            document.getElementById('status-text').innerHTML = 'GAME OVER<br>LINES: ' + score + '<br>PRESS SPACE';
        }
    </script>
</body>
</html>