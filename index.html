
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Space Ailen</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            user-select: none;
        }
        #game-container {
            position: relative;
            width: 512px;
            height: 512px;
        }
        canvas {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.2);
        }
        #score {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            text-shadow: 2px 2px #000;
            z-index: 10;
            pointer-events: none;
        }
        #start-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            text-align: center;
            z-index: 20;
            line-height: 2;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="score">SCORE: 0000</div>
        <div id="start-screen">CLICK TO START</div>
    </div>
    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        const SCENE_WIDTH = 128;
        const SCENE_HEIGHT = 128;
        
        const COLORS = {
            black: 0x000000,
            white: 0xFFFFFF,
            red: 0xFF004D,
            green: 0x00E436,
            blue: 0x29ADFF,
            yellow: 0xFFEC27,
            orange: 0xFFA300,
            pink: 0xFF77A8,
            purple: 0x83769c,
            cyan: 0x29ADFF
        };

        const ENEMY_SHAPES = [
            [[0,0,1,0,0],[0,1,1,1,0],[1,1,1,1,1],[1,0,1,0,1],[0,1,0,1,0]],
            [[0,0,1,0,0],[1,0,1,0,1],[1,1,1,1,1],[0,1,1,1,0],[1,0,1,0,1]],
            [[0,1,1,1,0],[1,1,1,1,1],[1,1,0,1,1],[1,1,1,1,1],[1,0,0,0,1]],
            [[1,0,1,0,1],[1,1,1,1,1],[0,1,1,1,0],[1,1,1,1,1],[0,1,0,1,0]],
            [[0,1,1,1,0],[1,1,0,1,1],[1,1,1,1,1],[0,0,1,0,0],[0,1,1,1,0]],
            [[1,1,0,1,1],[1,1,1,1,1],[0,1,1,1,0],[1,1,1,1,1],[1,0,0,0,1]],
            [[0,0,1,0,0],[0,1,1,1,0],[1,1,0,1,1],[0,1,1,1,0],[0,0,1,0,0]],
            [[1,0,0,0,1],[0,1,1,1,0],[1,1,1,1,1],[0,1,0,1,0],[1,0,0,0,1]]
        ];

        let scene, camera, renderer;
        let player, invaders = [], bullets = [], bunkerBlocks = [];
        let lastTime = 0;
        let score = 0;
        let gameActive = false;
        let invaderDirection = 1;
        let invaderMoveTimer = 0;
        let invaderMoveInterval = 1000;
        let audioCtx;
        let currentWave = 0;
        
        const keys = { ArrowLeft: false, ArrowRight: false, Space: false };

        function init() {
            const container = document.getElementById('game-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(COLORS.black);
            scene.fog = new THREE.Fog(COLORS.black, 60, 100);

            camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
            camera.position.set(0, 40, 40);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(SCENE_WIDTH, SCENE_HEIGHT, false);
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            createStars();
            createPlayer();
            createInvaders();
            createBunkers();

            window.addEventListener('keydown', (e) => {
                if(e.code === 'Space') keys.Space = true;
                if(e.code === 'ArrowLeft') keys.ArrowLeft = true;
                if(e.code === 'ArrowRight') keys.ArrowRight = true;
            });
            window.addEventListener('keyup', (e) => {
                if(e.code === 'Space') keys.Space = false;
                if(e.code === 'ArrowLeft') keys.ArrowLeft = false;
                if(e.code === 'ArrowRight') keys.ArrowRight = false;
            });

            document.addEventListener('click', () => {
                if (!gameActive) {
                    if (!audioCtx) initAudio();
                    startGame();
                }
            });

            renderer.setAnimationLoop(animate);
        }

        function initAudio() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            playMusic();
        }

        function playTone(freq, type, duration, vol = 0.1) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function playShoot() { playTone(400 + Math.random() * 200, 'square', 0.1, 0.1); }
        function playExplosion() { playTone(100, 'sawtooth', 0.3, 0.2); }
        function playStep() { playTone(150, 'square', 0.05, 0.05); }
        
        function playMusic() {
            if (!audioCtx) return;
            const tempo = 0.5;
            const notes = [110, 0, 110, 0, 123, 0, 98, 0];
            let noteIndex = 0;
            
            setInterval(() => {
                if (!gameActive) return;
                const freq = notes[noteIndex];
                if (freq > 0) playTone(freq, 'triangle', 0.2, 0.05);
                noteIndex = (noteIndex + 1) % notes.length;
            }, tempo * 1000);
        }

        function createStars() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 200; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 100,
                    (Math.random() - 0.5) * 200
                );
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: COLORS.white, size: 0.5 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
        }

        function createVoxelSprite(matrix, color, scale = 1) {
            const group = new THREE.Group();
            const geo = new THREE.BoxGeometry(1, 1, 1);
            const mat = new THREE.MeshLambertMaterial({ color: color });
            
            matrix.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val) {
                        const mesh = new THREE.Mesh(geo, mat);
                        mesh.position.set(x - row.length/2, -y + matrix.length/2, 0);
                        group.add(mesh);
                    }
                });
            });
            group.scale.set(scale, scale, scale);
            return group;
        }

        function createPlayer() {
            const shape = [
                [0,0,0,1,0,0,0],
                [0,0,1,1,1,0,0],
                [0,1,1,1,1,1,0],
                [1,1,1,1,1,1,1]
            ];
            player = createVoxelSprite(shape, COLORS.green, 1.5);
            player.position.set(0, 0, 20);
            scene.add(player);
        }

        function createInvaders() {
            invaders.forEach(i => scene.remove(i.mesh));
            invaders = [];
            
            const rows = 5;
            const cols = 8;
            const startX = -30;
            const startZ = -20;
            
            for(let r=0; r<rows; r++) {
                const shapeIndex = (r + currentWave) % ENEMY_SHAPES.length;
                const shape = ENEMY_SHAPES[shapeIndex];
                
                const colorKeys = ['red', 'yellow', 'purple', 'cyan', 'orange', 'pink'];
                const color = COLORS[colorKeys[shapeIndex % colorKeys.length]];

                for(let c=0; c<cols; c++) {
                    const inv = createVoxelSprite(shape, color, 1.2);
                    inv.position.set(startX + c * 8, 0, startZ + r * 6);
                    scene.add(inv);
                    invaders.push({ mesh: inv, active: true, row: r, col: c });
                }
            }
        }

        function createBunkers() {
            bunkerBlocks.forEach(b => scene.remove(b));
            bunkerBlocks = [];

            const shape = [
                [0,0,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1],
                [1,1,1,0,0,1,1,1],
                [1,1,1,0,0,1,1,1]
            ];

            const xOffsets = [-30, 0, 30];
            const zPos = 12;
            const scale = 1.0;

            xOffsets.forEach(xOffset => {
                shape.forEach((row, y) => {
                    row.forEach((val, x) => {
                        if (val) {
                            const geo = new THREE.BoxGeometry(1, 1, 1);
                            const mat = new THREE.MeshLambertMaterial({ color: COLORS.green });
                            const mesh = new THREE.Mesh(geo, mat);
                            mesh.position.set(xOffset + (x - row.length/2) * scale, (-y + shape.length/2) * scale, zPos);
                            mesh.scale.set(scale, scale, scale);
                            scene.add(mesh);
                            bunkerBlocks.push(mesh);
                        }
                    });
                });
            });
        }

        function startGame() {
            gameActive = true;
            score = 0;
            currentWave = 0;
            document.getElementById('score').innerText = `SCORE: 0000`;
            document.getElementById('start-screen').style.display = 'none';
            bullets.forEach(b => scene.remove(b.mesh));
            bullets = [];
            player.position.set(0, 0, 20);
            createInvaders();
            createBunkers();
            invaderMoveInterval = 1000;
        }

        function shoot() {
            if (bullets.filter(b => b.isPlayer).length > 0) return;
            playShoot();
            const geo = new THREE.BoxGeometry(0.5, 0.5, 2);
            const mat = new THREE.MeshBasicMaterial({ color: COLORS.white });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(player.position);
            mesh.position.z -= 2;
            scene.add(mesh);
            bullets.push({ mesh, isPlayer: true });
        }

        function enemyShoot() {
            if (invaders.length === 0) return;
            const shooter = invaders[Math.floor(Math.random() * invaders.length)];
            if (!shooter) return;
            
            const geo = new THREE.BoxGeometry(0.5, 0.5, 2);
            const mat = new THREE.MeshBasicMaterial({ color: COLORS.pink });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(shooter.mesh.position);
            mesh.position.z += 2;
            scene.add(mesh);
            bullets.push({ mesh, isPlayer: false });
        }

        function updateInvaders(dt) {
            invaderMoveTimer += dt;
            if (invaderMoveTimer > invaderMoveInterval) {
                invaderMoveTimer = 0;
                playStep();
                
                let moveDown = false;
                let minX = Infinity, maxX = -Infinity;
                
                invaders.forEach(inv => {
                    minX = Math.min(minX, inv.mesh.position.x);
                    maxX = Math.max(maxX, inv.mesh.position.x);
                });

                if ((maxX > 40 && invaderDirection > 0) || (minX < -40 && invaderDirection < 0)) {
                    invaderDirection *= -1;
                    moveDown = true;
                }

                invaders.forEach(inv => {
                    if (moveDown) {
                        inv.mesh.position.z += 4;
                    } else {
                        inv.mesh.position.x += invaderDirection * 4;
                    }
                    inv.mesh.rotation.z = (inv.mesh.rotation.z === 0) ? 0.2 : 0;
                });
                
                if (moveDown) {
                    invaderMoveInterval = Math.max(200, invaderMoveInterval * 0.9);
                    if (invaders.some(inv => inv.mesh.position.z > 15)) {
                        gameOver();
                    }
                }
                
                if (Math.random() < 0.3) enemyShoot();
            }
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('start-screen').style.display = 'block';
            document.getElementById('start-screen').innerHTML = `GAME OVER<br>SCORE: ${score}<br>CLICK TO RESTART`;
        }

        function animate(time) {
            const dt = time - lastTime;
            lastTime = time;

            if (gameActive) {
                if (keys.ArrowLeft && player.position.x > -40) player.position.x -= 0.5;
                if (keys.ArrowRight && player.position.x < 40) player.position.x += 0.5;
                
                if (keys.Space) {
                    shoot();
                    keys.Space = false;
                }

                for (let i = bullets.length - 1; i >= 0; i--) {
                    const b = bullets[i];
                    b.mesh.position.z += b.isPlayer ? -1 : 0.5;
                    
                    if (b.mesh.position.z < -60 || b.mesh.position.z > 40) {
                        scene.remove(b.mesh);
                        bullets.splice(i, 1);
                        continue;
                    }

                    let hitBunker = false;
                    for (let k = bunkerBlocks.length - 1; k >= 0; k--) {
                        const block = bunkerBlocks[k];
                        const dx = Math.abs(b.mesh.position.x - block.position.x);
                        const dy = Math.abs(b.mesh.position.y - block.position.y); 
                        const dz = Math.abs(b.mesh.position.z - block.position.z);
                        
                        if (dx < 1 && dy < 1 && dz < 1) {
                            scene.remove(block);
                            bunkerBlocks.splice(k, 1);
                            scene.remove(b.mesh);
                            bullets.splice(i, 1);
                            playStep(); 
                            hitBunker = true;
                            break;
                        }
                    }
                    if (hitBunker) continue;

                    if (b.isPlayer) {
                        for (let j = invaders.length - 1; j >= 0; j--) {
                            const inv = invaders[j];
                            const dx = Math.abs(b.mesh.position.x - inv.mesh.position.x);
                            const dz = Math.abs(b.mesh.position.z - inv.mesh.position.z);
                            
                            if (dx < 3 && dz < 2) {
                                scene.remove(inv.mesh);
                                scene.remove(b.mesh);
                                invaders.splice(j, 1);
                                bullets.splice(i, 1);
                                playExplosion();
                                score += 100;
                                document.getElementById('score').innerText = `SCORE: ${score.toString().padStart(4, '0')}`;
                                break;
                            }
                        }
                    } else {
                        const dx = Math.abs(b.mesh.position.x - player.position.x);
                        const dz = Math.abs(b.mesh.position.z - player.position.z);
                        if (dx < 3 && dz < 2) {
                            if (Math.random() < 0.75) {
                                scene.remove(b.mesh);
                                bullets.splice(i, 1);
                                continue;
                            }
                            playExplosion();
                            gameOver();
                        }
                    }
                }
                
                if (invaders.length === 0) {
                    currentWave++;
                    createInvaders();
                    invaderMoveInterval = Math.max(100, 1000 - (currentWave * 100));
                }

                updateInvaders(dt);
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>